{"version":3,"file":"useDraggableStack.js","sourceRoot":"","sources":["../../../../src/features/sort/hooks/useDraggableStack.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,OAAO,CAAC;AAChC,OAAO,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAC;AAC9D,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,wBAAwB,EAAE,sBAAsB,EAAE,MAAM,gBAAgB,CAAC;AAClF,OAAO,EAAE,gBAAgB,EAAgC,MAAM,oBAAoB,CAAC;AASpF,MAAM,CAAC,MAAM,iBAAiB,GAAG,CAAC,EAChC,YAAY,EACZ,aAAa,EACb,aAAa,EACb,GAAG,GAAG,CAAC,EACP,UAAU,GAAG,KAAK,EAClB,iBAAiB,GACQ,EAAE,EAAE;IAC7B,MAAM,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,uBAAuB,EAAE,gBAAgB,EAAE,GAAG,aAAa,EAAE,CAAC;IAC3G,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACpC,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC;IAC7C,MAAM,OAAO,GAAG,OAAO,CACrB,GAAG,EAAE,CACH,iBAAiB,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC,sBAAsB,EACxG,CAAC,UAAU,EAAE,iBAAiB,CAAC,CAChC,CAAC;IAEF,MAAM,EAAE,yBAAyB,EAAE,kBAAkB,EAAE,GAAG,gBAAgB,CAAC;QACzE,UAAU;QACV,YAAY;QACZ,aAAa;QACb,aAAa;QACb,iBAAiB,EAAE,OAAO;KAC3B,CAAC,CAAC;IAEH,kDAAkD;IAClD,mBAAmB,CACjB,GAAG,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAC9B,CAAC,SAAS,EAAE,SAAS,EAAE,EAAE;QACvB,0BAA0B;QAC1B,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;YACvB,OAAO;QACT,CAAC;QACD,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,iBAAiB,CAAC;QAC9C,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC;QAC5C,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC;QAC5C,MAAM,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,uBAAuB,CAAC;QAC1D,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,OAAO;QACT,CAAC;QAED,MAAM,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC;QAC7C,MAAM,eAAe,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,QAAQ,CAAC,CAAC;QACrE,MAAM,eAAe,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,QAAQ,CAAC,CAAC;QACrE,MAAM,gBAAgB,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;QACxC,MAAM,aAAa,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;QAC/C,UAAU;QAEV,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,SAAS,GAAG,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC;YAClE,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;YACpC,uBAAuB;YACvB,IAAI,MAAM,KAAK,QAAQ,EAAE,CAAC;gBACxB,SAAS;YACX,CAAC;YACD,iBAAiB;YAEjB,2CAA2C;YAC3C,MAAM,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC;YAC7D,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;gBAC5B,SAAS;YACX,CAAC;YACD,mCAAmC;YACnC,MAAM,OAAO,GAAG,SAAS,GAAG,SAAS,CAAC;YACtC,yDAAyD;YACzD,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK;gBACzB,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,OAAO,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;YAC5E,gDAAgD;YAChD,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;YAEjE,yDAAyD;YACzD,IAAI,SAAS,GAAG,eAAe,IAAI,SAAS,GAAG,eAAe,EAAE,CAAC;gBAC/D,gBAAgB,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;YAC9D,CAAC;iBAAM,IAAI,SAAS,GAAG,eAAe,IAAI,SAAS,GAAG,eAAe,EAAE,CAAC;gBACtE,gBAAgB,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;YAC9D,CAAC;QACH,CAAC;QACD,gCAAgC;QAChC,aAAa,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACtD,CAAC,EACD;QACE,UAAU;QACV,IAAI;QACJ,IAAI;QACJ,OAAO;QACP,kBAAkB;QAClB,gBAAgB;QAChB,uBAAuB;QACvB,iBAAiB;QACjB,gBAAgB;KACjB,CACF,CAAC;IAEF,OAAO,EAAE,yBAAyB,EAAE,kBAAkB,EAAE,CAAC;AAC3D,CAAC,CAAC","sourcesContent":["import { useMemo } from \"react\";\nimport { useAnimatedReaction } from \"react-native-reanimated\";\nimport { useDndContext } from \"../../../DndContext\";\nimport { swapByItemHorizontalAxis, swapByItemVerticalAxis } from \"../../../utils\";\nimport { useDraggableSort, type UseDraggableSortOptions } from \"./useDraggableSort\";\n\nexport type UseDraggableStackOptions = Pick<\n  UseDraggableSortOptions,\n  \"initialOrder\" | \"onOrderChange\" | \"onOrderUpdate\" | \"shouldSwapWorklet\"\n> & {\n  gap?: number;\n  horizontal?: boolean;\n};\nexport const useDraggableStack = ({\n  initialOrder,\n  onOrderChange,\n  onOrderUpdate,\n  gap = 0,\n  horizontal = false,\n  shouldSwapWorklet,\n}: UseDraggableStackOptions) => {\n  const { draggableActiveId, draggableOffsets, draggableRestingOffsets, draggableLayouts } = useDndContext();\n  const axis = horizontal ? \"x\" : \"y\";\n  const size = horizontal ? \"width\" : \"height\";\n  const worklet = useMemo(\n    () =>\n      shouldSwapWorklet ? shouldSwapWorklet : horizontal ? swapByItemHorizontalAxis : swapByItemVerticalAxis,\n    [horizontal, shouldSwapWorklet],\n  );\n\n  const { draggablePlaceholderIndex, draggableSortOrder } = useDraggableSort({\n    horizontal,\n    initialOrder,\n    onOrderChange,\n    onOrderUpdate,\n    shouldSwapWorklet: worklet,\n  });\n\n  // Track sort order changes and update the offsets\n  useAnimatedReaction(\n    () => draggableSortOrder.value,\n    (nextOrder, prevOrder) => {\n      // Ignore initial reaction\n      if (prevOrder === null) {\n        return;\n      }\n      const { value: activeId } = draggableActiveId;\n      const { value: layouts } = draggableLayouts;\n      const { value: offsets } = draggableOffsets;\n      const { value: restingOffsets } = draggableRestingOffsets;\n      if (!activeId) {\n        return;\n      }\n\n      const activeLayout = layouts[activeId].value;\n      const prevActiveIndex = prevOrder.findIndex((id) => id === activeId);\n      const nextActiveIndex = nextOrder.findIndex((id) => id === activeId);\n      const nextActiveOffset = { x: 0, y: 0 };\n      const restingOffset = restingOffsets[activeId];\n      // return;\n\n      for (let nextIndex = 0; nextIndex < nextOrder.length; nextIndex++) {\n        const itemId = nextOrder[nextIndex];\n        // Skip the active item\n        if (itemId === activeId) {\n          continue;\n        }\n        // @TODO grid x,y\n\n        // Skip items that haven't changed position\n        const prevIndex = prevOrder.findIndex((id) => id === itemId);\n        if (nextIndex === prevIndex) {\n          continue;\n        }\n        // Calculate the directional offset\n        const moveCol = nextIndex - prevIndex;\n        // Apply the offset to the item from its resting position\n        offsets[itemId][axis].value =\n          restingOffsets[itemId][axis].value + moveCol * (activeLayout[size] + gap);\n        // Reset resting offsets to new updated position\n        restingOffsets[itemId][axis].value = offsets[itemId][axis].value;\n\n        // Accummulate the directional offset for the active item\n        if (nextIndex < nextActiveIndex && prevIndex > prevActiveIndex) {\n          nextActiveOffset[axis] += layouts[itemId].value[size] + gap;\n        } else if (nextIndex > nextActiveIndex && prevIndex < prevActiveIndex) {\n          nextActiveOffset[axis] -= layouts[itemId].value[size] + gap;\n        }\n      }\n      // Update the active item offset\n      restingOffset[axis].value += nextActiveOffset[axis];\n    },\n    [\n      horizontal,\n      axis,\n      size,\n      worklet,\n      draggableSortOrder,\n      draggableLayouts,\n      draggableRestingOffsets,\n      draggableActiveId,\n      draggableOffsets,\n    ],\n  );\n\n  return { draggablePlaceholderIndex, draggableSortOrder };\n};\n"]}